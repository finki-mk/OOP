/*
–î–∞–¥–µ–Ω–∞ –µ –∫–ª–∞—Å–∞ User –≤–æ –∫–æ—ò–∞ —Å–µ —á—É–≤–∞–∞—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∑–∞ –∫–æ—Ä–∏—Å–Ω–∏—á–∫–æ –∏–º–µ, –∏–º–µ –Ω–∞ –∫–æ–º–ø–∞–Ω–∏—ò–∞—Ç–∞ –≤–æ –∫–æ—ò–∞ —Ä–∞–±–æ—Ç–∏ –∏ –Ω–∏–≤–æ –Ω–∞ –ø–æ–∑–∏—Ü–∏—ò–∞—Ç–∞ –≤–æ –∫–æ–º–ø–∞–Ω–∏—ò–∞—Ç–∞ (–±—Ä–æ—ò –æ–¥ 1 - 10). –í–æ –∫–ª–∞—Å–∞—Ç–∞ —Å–µ –¥–µ—Ñ–∏–Ω–∏—Ä–∞–Ω–∏ —Å–∏—Ç–µ –ø–æ—Ç—Ä–µ–±–Ω–∏ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∏, –æ–ø–µ—Ä–∞—Ç–æ—Ä–∏, set, get –º–µ—Ç–æ–¥–∏, –æ–ø–µ—Ä–∞—Ç–æ—Ä –∑–∞ –ø–µ—á–∞—Ç–µ—ö–µ –∏ –≤—á–∏—Ç—É–≤–∞—ö–µ. –û–≤–∞–∞ –∫–ª–∞—Å–∞ –Ω–µ —Ç—Ä–µ–±–∞ –¥–∞ —Å–µ –º–µ–Ω—É–≤–∞.

–î–∞ —Å–µ –¥–µ—Ñ–∏–Ω–∏—Ä–∞ –∫–ª–∞—Å–∞ Group —à—Ç–æ —ú–µ –æ–∑–Ω–∞—á—É–≤–∞ –≥—Ä—É–ø–∞ –∫–æ—Ä–∏—Å–Ω–∏—Ü–∏. –í–æ –Ω–µ–∞ —Å–µ —á—É–≤–∞–∞—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∑–∞:

–ß–ª–µ–Ω–æ–≤–∏—Ç–µ –Ω–∞ –≥—Ä—É–ø–∞—Ç–∞ (–¥–∏–Ω–∞–º–∏—á–∫–∏ –∞–ª–æ—Ü–∏—Ä–∞–Ω–∞ –Ω–∏–∑–∞ –æ–¥ –æ–±—ò–µ–∫—Ç–∏ –æ–¥ –∫–ª–∞—Å–∞—Ç–∞ User)
–ì–æ–ª–µ–º–∏–Ω–∞ –Ω–∞ –≥—Ä—É–ø–∞—Ç–∞ (–±—Ä–æ—ò –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç–∏ –≤–æ –Ω–∏–∑–∞—Ç–∞)
–ò–º–µ –Ω–∞ –≥—Ä—É–ø–∞—Ç–∞ (–Ω–∏–∑–∞ –æ–¥ –Ω–∞—ò–º–Ω–æ–≥—É 50 –∑–Ω–∞—Ü–∏)
–ó–∞ –∫–ª–∞—Å–∞—Ç–∞ –¥–∞ —Å–µ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–∞—Ç:

–ü–æ—Ç—Ä–µ–±–Ω–∏—Ç–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∏ –∏ –¥–µ—Å—Ç—Ä—É–∫—Ç–æ—Ä
–º–µ—Ç–æ–¥ void addMember (User & u)- —à—Ç–æ —ú–µ –¥–æ–¥–∞–≤–∞ –Ω–æ–≤ —á–ª–µ–Ω –≤–æ –≥—Ä—É–ø–∞—Ç–∞. –ê–∫–æ –≤–µ—ú–µ –ø–æ—Å—Ç–æ–∏ —á–ª–µ–Ω —Å–æ –∏—Å—Ç–æ –∫–æ—Ä–∏—Å–Ω–∏—á–∫–æ –∏–º–µ, –¥–∞ —Å–µ —Ñ—Ä–ª–∏ –∏—Å–∫–ª—É—á–æ–∫ –æ–¥ —Ç–∏–ø OperationNotSupported. –¢—Ä–µ–±–∞ –¥–∞ —Å–µ –æ–±–µ–∑–±–µ–¥–∏ —Å–ø—Ä–∞–≤—É–≤–∞—ö–µ —Å–æ –æ–≤–æ—ò –∏—Å–∫–ª—É—á–æ–∫ –≤–æ —Ñ—É–Ω–∫—Ü–∏—ò–∞—Ç–∞ main. –ü—Ä–∏ —Ñ–∞—ú–∞—ö–µ –Ω–∞ –æ–≤–æ—ò –∏—Å–∫–ª—É—á–æ–∫ –¥–∞ —Å–µ –∏—Å–ø–µ—á–∞—Ç–∏ –ø–æ—Ä–∞–∫–∞ "Username already exists".
–º–µ—Ç–æ–¥ double rating() - —à—Ç–æ —ú–µ –≥–æ –ø—Ä–µ—Å–º–µ—Ç–∞ —Ä–µ—ò—Ç–∏–Ω–≥–æ—Ç –Ω–∞ –≥—Ä—É–ø–∞—Ç–∞ —Å–æ —Ñ–æ—Ä–º—É–ª–∞—Ç–∞: (10 - –ø—Ä–æ—Å–µ—á–Ω–æ_–Ω–∏–≤–æ_–Ω–∞_–ø–æ–∑–∏—Ü–∏–∏—Ç–µ_–Ω–∞_—á–ª–µ–Ω–æ–≤–∏—Ç–µ) * –±—Ä–æ—ò_–Ω–∞_—á–ª–µ–Ω–æ–≤–∏ / 100.
–î–∞ —Å–µ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ –∫–ª–∞—Å–∞ PrivateGroup –≤–æ –∫–æ—ò–∞ –ø–æ–∫—Ä–∞—ò –æ—Å–Ω–æ–≤–Ω–∏—Ç–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∑–∞ –µ–¥–Ω–∞ –≥—Ä—É–ø–∞ —ú–µ —Å–µ —á—É–≤–∞ –∏:

–ö–∞–ø–∞—Ü–∏—Ç–µ—Ç –Ω–∞ –ø—Ä–∏–≤–∞—Ç–Ω–∞—Ç–∞ –≥—Ä—É–ø–∞ (—Ü–µ–ª –±—Ä–æ—ò). –ö–∞–ø–∞—Ü–∏—Ç–µ—Ç–æ—Ç –µ –∏—Å—Ç –∑–∞ —Å–∏—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω–∏ –≥—Ä—É–ø–∏ –∏ –∏–Ω–∏—Ü–∏—ò–∞–ª–Ω–æ –∏–º–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç 10. –¢–æ—ò –º–æ–∂–µ –¥–∞ —Å–µ –º–µ–Ω—É–≤–∞.
–ó–∞ –∫–ª–∞—Å–∞—Ç–∞ –¥–∞ —Å–µ –∏–º–ø–ª–µ–º–µ—Ç–Ω–∏—Ä–∞–∞—Ç –ø–æ—Ç—Ä–µ–±–Ω–∏—Ç–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∏ –∏ –¥–µ—Å—Ç—Ä—É–∫—Ç–æ—Ä.

–í–æ –∫–ª–∞—Å–∞—Ç–∞ PrivateGroup –¥–∞ —Å–µ –ø—Ä–µ–ø–æ–∫—Ä–∏—ò–∞—Ç –º–µ—Ç–æ–¥–∏—Ç–µ –æ–¥ –∫–ª–∞—Å–∞—Ç–∞ Group –Ω–∞ —Å–ª–µ–¥–Ω–∏–æ—Ç –Ω–∞—á–∏–Ω:

–º–µ—Ç–æ–¥ void addMember (User & u) - —à—Ç–æ —ú–µ –¥–æ–¥–∞–≤–∞ –Ω–æ–≤ —á–ª–µ–Ω –≤–æ –≥—Ä—É–ø–∞—Ç–∞. –î–∞ –Ω–µ —Å–µ –¥–æ–∑–≤–æ–ª–∏ –Ω–∞–¥–º–∏–Ω—É–≤–∞—ö–µ –Ω–∞ –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç–æ—Ç –Ω–∞ –≥—Ä—É–ø–∞—Ç–∞. –ê–∫–æ —Å–µ –Ω–∞–ø—Ä–∞–≤–∏ –æ–±–∏–¥ –¥–∞ —Å–µ –¥–æ–¥–∞–¥–µ —á–ª–µ–Ω –∫–æ–≥–∞ –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç–æ—Ç –µ –∏—Å–ø–æ–ª–Ω–µ—Ç –¥–∞ —Å–µ —Ñ—Ä–ª–∏ –∏—Å–∫–ª—É—á–æ–∫ –æ–¥ —Ç–∏–ø OperationNotSupported. –¢—Ä–µ–±–∞ –¥–∞ —Å–µ –æ–±–µ–∑–±–µ–¥–∏ —Å–ø—Ä–∞–≤—É–≤–∞—ö–µ —Å–æ –æ–≤–æ—ò –∏—Å–∫–ª—É—á–æ–∫ –≤–æ —Ñ—É–Ω–∫—Ü–∏—ò–∞—Ç–∞ main. –ü—Ä–∏ —Ñ–∞—ú–∞—ö–µ –Ω–∞ –æ–≤–æ—ò –∏—Å–∫–ª—É—á–æ–∫ –¥–∞ —Å–µ –∏—Å–ø–µ—á–∞—Ç–∏ –ø–æ—Ä–∞–∫–∞ "The group‚Äôs capacity has been exceeded.".
–º–µ—Ç–æ–¥ double rating() - —à—Ç–æ —ú–µ –≥–æ –ø—Ä–µ—Å–º–µ—Ç–∞ —Ä–µ—ò—Ç–∏–Ω–≥–æ—Ç –Ω–∞ –≥—Ä—É–ø–∞—Ç–∞ —Å–æ —Ñ–æ—Ä–º—É–ª–∞—Ç–∞: (10 - –ø—Ä–æ—Å–µ—á–Ω–æ_–Ω–∏–≤–æ_–Ω–∞_–ø–æ–∑–∏—Ü–∏–∏—Ç–µ_–Ω–∞_—á–ª–µ–Ω–æ–≤–∏—Ç–µ) * (–±—Ä–æ—ò_–Ω–∞_—á–ª–µ–Ω–æ–≤–∏ / –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç_–Ω–∞_–≥—Ä—É–ø–∞) * –∫–æ–µ—Ñ–∏—Ü–∏–µ–Ω—Ç_–∑–∞_–ø—Ä–∏–≤–∞—Ç–Ω–∞_–≥—Ä—É–ø–∞. –ö–æ–µ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ—Ç –∑–∞ –ø—Ä–∏–≤–∞—Ç–Ω–∞ –≥—Ä—É–ø–∞ –µ –∏—Å—Ç –∑–∞ —Å–∏—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω–∏ –≥—Ä—É–ø–∏ –∏ –∏–∑–Ω–µ—Å—É–≤–∞ 0.8. –¢–æ—ò –Ω–µ –º–æ–∂–µ –¥–∞ —Å–µ –º–µ–Ω—É–≤–∞!
–ó–∞ –¥–≤–µ—Ç–µ –∫–ª–∞—Å–∏ –¥–∞ —Å–µ –¥–µ—Ñ–∏–Ω–∏—Ä–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä –∑–∞ –ø–µ—á–∞—Ç–µ—ö–µ <<. –§–æ—Ä–º–∞—Ç–æ—Ç –Ω–∞ –ø–µ—á–∞—Ç–µ—ö–µ –Ω–∞ –¥–≤–µ—Ç–µ –≥—Ä—É–ø–∏ –ø–æ–≥–ª–µ–¥–Ω–µ—Ç–µ –≥–æ –≤–æ –ø—Ä–≤–∏—Ç–µ –¥–≤–∞ —Ç–µ—Å—Ç –ø—Ä–∏–º–µ—Ä–∞.

*/

#include<string.h>
#include<iostream>
using namespace std;

class OperationNotSupported{
private:
    char msg[50];
public:
    OperationNotSupported(char * msg = "")
    {
        strcpy(this->msg,msg);
    }
    void print()
    {
        cout<<msg<<endl;
    }

};


class User {
    char *username;
    char *companyName;
    int position;

    void copy(const User &u) {
        this->username = new char[strlen(u.username) + 1];
        strcpy(this->username, u.username);
        this->companyName = new char[strlen(u.companyName) + 1];
        strcpy(this->companyName, u.companyName);
        this->position = u.position;
    }

public:
    User(char *username = "", char *companyName = "", int position = 0) {
        this->username = new char[strlen(username) + 1];
        strcpy(this->username, username);
        this->companyName = new char[strlen(companyName) + 1];
        strcpy(this->companyName, companyName);
        this->position = position;
    }

    User(const User &u) {
        copy(u);
    }

    User &operator=(const User &u) {
        if (this != &u) {
            delete[] username;
            delete[] companyName;
            copy(u);
        }
        return *this;
    }

    ~User() {
        delete[] username;
        delete[] companyName;
    }

    char *getUsername() const {
        return username;
    }

    void setUsername(char *username) {
        this->username = new char[strlen(username) + 1];
        strcpy(this->username, username);
    }

    char *getCompanyName() const {
        return companyName;
    }

    void setCompanyName(char *companyName) {
        this->companyName = new char[strlen(companyName) + 1];
        strcpy(this->companyName, companyName);
    }

    int getPosition() const {
        return position;
    }

    void setPosition(int position) {
        this->position = position;
    }


    friend ostream &operator<<(ostream &os, const User &user) {
        return os << "Username: " << user.username
                  << " Company name: " << user.companyName
                  << " Position: " << user.position;
    }

    friend istream &operator>>(istream &in, User &user) {
        return in >> user.username >> user.companyName >> user.position;
    }

    bool operator==(User &u) {
        return strcmp(this->username, u.username) == 0;
    }
};


class Group{
protected:
    User * users;
    int n;
    char ime[50];
public:
    Group(char * ime = "")
    {
        strcpy(this->ime,ime);
        users = 0;
        n = 0;
    }
    Group(const Group & g)
    {
        strcpy(this->ime,g.ime);
        users = new User[g.n];
        n = g.n;
        for(int i=0;i<n;i++)
        {
            users[i] = g.users[i];
        }
    }
    Group& operator=(const Group & g)
    {
        if(this!=&g){
            strcpy(this->ime,g.ime);
            delete [] users;
            users = new User[g.n];
            n = g.n;
            for(int i=0;i<n;i++)
            {
                users[i] = g.users[i];
            }
        }
        return *this;
    }
    ~Group()
    {
        delete [] users;
    }
  double getAvgPosition()
    {
        if(n==0)
            return 0;
        int sum = 0;
        for(int i=0;i<n;i++)
        {
            sum+=users[i].getPosition();
        }
        return (double)sum/n;
    }
virtual double rating(){
    return (10-getAvgPosition())*n/100;
    }

 virtual  void addMember(User & u)
    {
        for(int i=0;i<n;i++)
        {
            if(strcmp(users[i].getUsername(),u.getUsername())==0)
            {
                throw OperationNotSupported("Username already exists");
            }
        }

            User * temp = new User[n+1];
            for(int i=0;i<n;i++)
            {
                temp[i]= users[i];
            }
            temp[n++] = u;
            delete [] users;
            users = temp;
    }

    friend ostream& operator<<(ostream & out, Group & g)
    {
        out<<"Group: "<<g.ime<<endl;
        out<<"Members: "<<g.n<<endl;
        out<<"Rating: "<<g.rating()<<endl;
        out<<"Members list:"<<endl;
        for(int i=0;i<g.n;i++)
        {
          out<<i+1<<". ";
          out<<g.users[i]<<endl;
        }
        return out;
    }

};
class PrivateGroup:public Group{
private:
    static int capacity;
    const static float koeficient;
public:
    PrivateGroup(char * ime = "")
    :Group(ime){}
    static int getCapacity(){return capacity;}
    static void setCapacity(int newCapacity)
    {
        capacity = newCapacity;
    }
    void addMember(User & u)
    {
        if(n>=capacity)
        {
            throw OperationNotSupported("The groupís capacity has been exceeded.");
        }
        Group::addMember(u);
    }
    double rating()
    {
        return (10-getAvgPosition())*(n/capacity)*koeficient;
    }
    friend ostream& operator<<(ostream & out,PrivateGroup & g)
    {

        out<<"Private Group: "<<g.ime<<endl;
        out<<"Members: "<<g.n<<endl;
        out<<"Rating: "<<g.rating()<<endl;
        out<<"Members list:"<<endl;
        if(g.n==0)
        {
            out<<"EMPTY"<<endl;
        }
        else
        {
        for(int i=0;i<g.n;i++)
        {
          out<<i+1<<". ";
          out<<g.users[i]<<endl;
        }
        }
        return out;
    }
};
int PrivateGroup::capacity = 10;
const float PrivateGroup::koeficient = 0.8;

int main() {
    int testCase;
    cin >> testCase;
    if (testCase == 1) {
        cout << "TESTING CLASS GROUP: CONSTRUCTOR AND OPERATOR <<" << endl;
        Group g("test");
        cout << g;
    } else if (testCase == 2) {
        cout << "TESTING CLASS PRIVATE GROUP: CONSTRUCTOR AND OPERATOR <<" << endl;
        PrivateGroup pg("private test");
        cout << pg;
    } else if (testCase == 3) {
        cout << "TESTING CLASS GROUP: CONSTRUCTOR, METHOD ADD_MEMBER AND OPERATOR <<" << endl;
        Group *g = new Group("FINKI students");
        int n;
        cin >> n;
        for (int i = 0; i < n; i++) {
            User u;
            cin >> u;
            g->addMember(u);
        }
        cout << *g;
        delete g;
    } else if (testCase == 4) {
        cout << "TESTING CLASS PRIVATE_GROUP: CONSTRUCTOR, METHOD ADD_MEMBER AND OPERATOR <<" << endl;
        Group *g = new PrivateGroup("FINKI students");
        int n;
        cin >> n;
        for (int i = 0; i < n; i++) {
            User u;
            cin >> u;
            g->addMember(u);
        }
        cout << *g;
        delete g;
    } else if (testCase == 5) {
        cout << "TESTING CLASS GROUP: CONSTRUCTOR, METHOD ADD_MEMBER, EXCEPTION AND OPERATOR <<" << endl;
        Group *g = new Group("FINKI students");
        int n;
        cin >> n;
        for (int i = 0; i < n; i++) {
            User u;
            cin >> u;
            try {
                g->addMember(u);
            } catch (OperationNotSupported &e) {
                e.print();
            }
        }
        cout << *g;
        delete g;
    } else if (testCase == 6) {
        cout << "TESTING CLASS PRIVATE GROUP: CONSTRUCTOR, METHOD ADD_MEMBER, EXCEPTION AND OPERATOR <<" << endl;
        Group *g = new PrivateGroup("FINKI");
        int n;
        cin >> n;
        for (int i = 0; i < n; i++) {
            User u;
            cin >> u;
            try {
                g->addMember(u);
            } catch (OperationNotSupported e) {
                e.print();
            }
        }
        cout << *g;
        delete g;
    } else if (testCase == 7) {
        cout << "TESTING CLASS PRIVATE GROUP: CONSTRUCTOR, METHOD ADD_MEMBER AND CHANGE OF STATIC MEMBER"
             << endl;
        Group *g = new PrivateGroup("FINKI");
        int n;
        cin >> n;
        for (int i = 0; i < n; i++) {
            User u;
            cin >> u;
            g->addMember(u);
        }
        cout << "RATING BEFORE CHANGE" << endl;
        cout << g->rating();
        PrivateGroup::setCapacity(20);
        cout << "RATING AFTER CHANGE" << endl;
        cout << g->rating();
        delete g;
    }
    else if (testCase==8) {
        cout << "TESTING CLASS PRIVATE GROUP: CONSTRUCTOR, METHOD ADD_MEMBER, EXCEPTION AND CHANGE OF STATIC MEMBER"
             << endl;

        Group *g = new PrivateGroup("FINKI");
        int n;
        cin >> n;
        for (int i = 0; i < n; i++) {
            User u;
            cin >> u;
            try {
                g->addMember(u);
            } catch (OperationNotSupported & e) {
                int capacity = PrivateGroup::getCapacity();
                cout<<"Increasing capacity from "<<capacity<<" to "<<capacity+1<<endl;
                PrivateGroup::setCapacity(capacity+1);
                g->addMember(u);
                cout<<g->rating()<<endl;
            }
        }

    }else {
        cout<<"INTEGRATION TEST"<<endl;
        char name [50];
        int nGroups;
        cin>>nGroups;
        Group ** groups = new Group * [nGroups];
        for (int i=0;i<nGroups;i++) {
            int type;
            cin>>type;
            cin>>name;
            if (type==1) { //normal group
                groups[i] = new Group(name);
            } else { //private group
                groups[i] = new PrivateGroup(name);
            }
            int nUsers;
            cin>>nUsers;
            for (int j=0;j<nUsers;j++) {
                User u;
                cin>>u;
                try {
                    groups[i]->addMember(u);
                } catch (OperationNotSupported e) {
                    e.print();
                }
            }
        }

        cout<<"BEFORE CHANGE OF PRIVATE GROUP COEFFICIENT"<<endl;
        for (int i = 0; i < nGroups; ++i) {
            cout<<*groups[i];
        }
        PrivateGroup::setCapacity(15);
        cout<<"AFTER CHANGE OF PRIVATE GROUP COEFFICIENT"<<endl;
        for (int i = 0; i < nGroups; ++i) {
            cout<<*groups[i];
        }
    }
}
